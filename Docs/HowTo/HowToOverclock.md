# How to implement overclocking

This how-to guide explains how overclocking is implemented in vAmiga. 

## Running the CPU with native speed

I a real Amiga, the components are driven by different clocks. All clock signals are generated by master clock  running at 28.375160 MHz on PAL machines. From the master clock signal the CPU clock signal is derived by dividing the master clock frequency by four. Thus, the CPU is run with 7.093790 MHz on PAL machines. In addition, there are two more clocks: The E-clock and the color clock. The E-clock signal is generated by the CPU itself by dividing it's own clock signal by 10. It is used to drive the two interface adapters (CIAs), but plays now role here. The color clock is of high importance, because it is used to drive DMA. The color clock signal is derived by dividing the master clock frequency by 8. Thus, we end up with a bus speed of 3.546895 MHz on PAL machines. 

To sum up: In the standard configuration, two CPU cycles are performed within one DMA cycle which makes it pretty easy to synchronize the CPU with the bus. In vAmiga, timing is taken care of the `sync` function which is part of the Moira class. Reminder: In precise cylce mode, `sync` is called before each memory access, thus multiple times during the execution of a single instruction. In simple cycle mode, `sync` is only called once per instruction, at the end of the instruction handler. In both modes, the number of elapsed CPU cycles is handed over to the `sync` function as argument. Remember: Two CPU cycles correspond to 1 DMA cycle. This means that if `sync` is called with a value of, e.g., 4, vAmiga needs to emulate the surrounding logic for 2 bus cycles. After that, the memory access can be performed.

Let's have a look at how this standard case is implemented in vAmiga:

```c++ 
void
Moira::sync(int cycles)
{
    CPU *cpu = (CPU *)this;

    if (!cpu->config.overclocking) {

        // Advance the CPU clock
        clock += cycles;

        // Emulate Agnus up to the same cycle
        agnus.execute(CPU_AS_DMA_CYCLES(cycles));

    } else {

        // The overclocking case 
        ...
    }
}
```

The implementation is pretty straight forward. If overclocking is disabled, the internal clock counter (variable `clock`) is incremented by the number of elapsed cycles and Agnus is asked to emulate the surrounding logic for the correspondig amount of bus cycles. As you may have already guessed, the conversion from CPU cycles to DMA cycles is just a division by two:

```c++
// Converts CPU cycles to DMA cycles
#define CPU_AS_DMA_CYCLES(cycles) (cycles >> 1)
```

## Overclocking the CPU

vAmiga has the capability to emulate an overclocked CPU. This is done by assigning `config.overclocking` a non-zero value. In this case, the value is interpreted as an overclocking factor. E.g., if the value is set 



void
Moira::sync(int cycles)
{
    CPU *cpu = (CPU *)this;

    if (!cpu->config.overclocking) {

        // Advance the CPU clock
        clock += cycles;

        // Emulate Agnus up to the same cycle
        agnus.execute(CPU_AS_DMA_CYCLES(cycles));

    } else {

        // Compute the number of mico-cycles executed in one DMA cycle
        auto microCyclesPerCycle = 2 * cpu->config.overclocking;

        // Execute some cycles at normal speed if required
        while (cpu->slowCycles && cycles) {

            cpu->penalty += microCyclesPerCycle;
            cycles--;
            cpu->slowCycles--;
        }

        // Execute all other cycles
        cpu->penalty += cycles;

        while (cpu->penalty >= microCyclesPerCycle) {

            // Advance the CPU clock by one DMA cycle
            clock += 2;

            // Emulate Agnus for one DMA cycle
            agnus.execute();

            cpu->penalty -= microCyclesPerCycle;
        }
    }
}


TODO
